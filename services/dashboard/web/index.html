<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌌 HolographicMemory SOA Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* SmartHaus Design System Variables */
        :root {
            /* Quantum Layer - Deep, Foundational */
            --quantum-void: #000120;
            --quantum-dark: #1A1F3A;
            --quantum-blue: #1E3A8A;
            --quantum-electric: #61dafb;
            
            /* Chemistry Layer - Binding, Energy */
            --chemistry-purple: #6366F1;
            --chemistry-magenta: #A855F7;
            --chemistry-cyan: #06B6D4;
            --chemistry-teal: #14B8A6;
            
            /* Biology Layer - Living, Adaptive */
            --biology-emerald: #10B981;
            --biology-gold: #F59E0B;
            --biology-coral: #FB7185;
            --biology-amber: #FCD34D;
            
            /* Mathematical Purity */
            --pure-white: #FFFFFF;
            --proof-gray-50: #FAFAFA;
            --proof-gray-100: #F4F4F5;
            --proof-gray-200: #E4E4E7;
            --proof-gray-300: #D4D4D8;
            --proof-gray-400: #A1A1AA;
            --proof-gray-500: #71717A;
            --proof-gray-600: #52525B;
            --proof-gray-700: #3F3F46;
            --proof-gray-800: #27272A;
            --proof-gray-900: #18181B;
            
            /* Header Background Colors */
            --header-bg: rgba(255, 255, 255, 0.95);
            --header-bg-solid: #fafafa;
            --header-bg-medium: #f5f5f5;
            --header-bg-dark: #e5e5e5;
            
            /* Semantic Assignments */
            --color-background: var(--header-bg-solid);
            --color-surface: var(--header-bg-medium);
            --color-border: var(--proof-gray-200);
            --color-text-primary: var(--quantum-void);
            --color-text-secondary: var(--quantum-blue);
            --color-text-muted: var(--proof-gray-600);
            
            /* Spacing System */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.25rem;
            --space-6: 1.5rem;
            --space-8: 2rem;
            --space-10: 2.5rem;
            --space-12: 3rem;
            --space-16: 4rem;
            --space-20: 5rem;
            --space-24: 6rem;
            --space-32: 8rem;
            
            /* Typography */
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-2xl: 1.5rem;
            --font-size-3xl: 1.875rem;
            --font-size-4xl: 2.25rem;
            
            /* Border Radius */
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            --radius-full: 9999px;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 30px; padding: 16px 24px; border: 1px solid var(--color-border); border-radius: 12px; background: #fafafa; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1); }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo { height: 56px; width: 140px; object-fit: contain; }

        .header-title h1 { font-family: 'Inter', sans-serif; font-size: 1.777rem; margin-bottom: 6px; color: #000120; text-shadow: none; }

        .header-title p { font-family: 'Inter', sans-serif; font-size: 0.875rem; color: #52525B; opacity: 1; }

        .header-right { display: flex; align-items: center; gap: 20px; }

        .nav { display: flex; align-items: center; gap: 16px; }
        .nav a { color: #111827; text-decoration: none; font-family: 'Inter', sans-serif; font-weight: 500; font-size: 0.875rem; padding: 6px 8px; border-radius: 6px; }
        .nav a:hover { background: var(--proof-gray-100); }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #10B981;
            color: white;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: white;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .sidebar {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 20px;
        }

        .main-content {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 20px;
        }

        .terminal-container { background: #000; border: 1px solid #333; border-radius: 8px; height: 420px; }

        .command-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .command-input input {
            flex: 1;
            background: #000;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 12px;
            border-radius: 5px;
            font-family: inherit;
            font-size: 14px;
        }

        .command-input button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .command-input button:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }

        .output {
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'SF Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .output-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .output-line.success { color: #00ff88; }
        .output-line.error { color: #ff4444; }
        .output-line.warning { color: #ffaa00; }
        .output-line.info { color: #4488ff; }
        .output-line.prompt { color: #00ff88; font-weight: bold; }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .status-card h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .status-card .value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status-card .status {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quick-commands {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .quick-command {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            font-size: 12px;
        }

        .quick-command:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-2px);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 1000;
        }

        .connection-status.connected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .connection-status.disconnected {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        .table th, .table td {
            border: 1px solid #333;
            padding: 8px 12px;
            text-align: left;
        }

        .table th {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            font-weight: bold;
        }

        .table tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.2);
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #00cc6a;
        }
        
        /* New full-width SmartHaus header + metrics dashboard */
        :root { --header-height: 72px; }
        body { padding-top: var(--header-height); }
        .page-header { position: fixed; top:0; left:0; right:0; height: var(--header-height); background: var(--header-bg-solid); border-bottom:1px solid var(--color-border); box-shadow: var(--shadow-sm); z-index: 1000; }
        .header-container { max-width: 120rem; margin: 0 auto; height: 100%; display:flex; align-items:center; justify-content:space-between; padding: 0 var(--space-8); }
        .page-header .logo { height: 56px; width: 140px; object-fit: contain; }
        .main-nav { display:flex; align-items:center; gap: var(--space-5); }
        .main-nav a { color: var(--color-text-primary); text-decoration:none; font-weight:600; font-size: var(--font-size-sm); padding: var(--space-2) var(--space-3); border-radius: var(--radius-sm); }
        .main-nav a:hover { background: var(--proof-gray-100); }
        .system-status { display:flex; align-items:center; gap: var(--space-2); background: var(--biology-emerald); color: white; padding: var(--space-2) var(--space-3); border-radius: var(--radius-full); font-size: var(--font-size-sm); }
        .header { display: none !important; }
    </style>
</head>
<body>
    <!-- Full-width SmartHaus Header -->
    <header class="page-header">
      <div class="header-container">
        <img src="/assets/images/smarthaus-logo-light.svg" alt="SmartHaus" class="logo">
        <nav class="main-nav">
          <a id="nav-dashboard" href="#">Dashboard</a>
          <a id="nav-terminal" href="#">Terminal</a>
          <a id="nav-analytics" href="#">Analytics</a>
          <a id="nav-status" href="#">Status</a>
          <a id="nav-docs" href="#">Docs</a>
        </nav>
        <div class="system-status"><span class="status-dot" style="width:8px;height:8px;border-radius:50%;background:white"></span> SOA System Online</div>
      </div>
    </header>
    <div class="container">

        <div class="status-grid">
            <div class="status-card">
                <h3>🚀 GPU Status</h3>
                <div class="value" id="gpuStatus">Checking...</div>
                <div class="status">Metal Acceleration</div>
            </div>
            <div class="status-card">
                <h3>📊 Operations/sec</h3>
                <div class="value" id="opsPerSec">2.1M</div>
                <div class="status">Current Performance</div>
            </div>
            <div class="status-card">
                <h3>⚡ Latency</h3>
                <div class="value" id="latency">0.8ms</div>
                <div class="status">Average Response</div>
            </div>
            <div class="status-card">
                <h3>🧠 RAM Usage</h3>
                <div class="value" id="memoryUsage">2.3GB</div>
                <div class="status">System Memory</div>
            </div>
            <div class="status-card">
                <h3>💾 HWP Storage</h3>
                <div class="value" id="hwpStorage">0KB</div>
                <div class="status">Holographic Files</div>
            </div>
        </div>

        <div class="dashboard">
            <div class="sidebar">
                <h3 style="color: #00ff88; margin-bottom: 15px;">🎯 Quick Commands</h3>
                <div class="quick-commands">
                    <div class="quick-command" onclick="executeCommand('status')">System Status</div>
                    <div class="quick-command" onclick="executeCommand('services')">SOA Services</div>
                    <div class="quick-command" onclick="executeCommand('gpu')">GPU Status</div>
                    <div class="quick-command" onclick="executeCommand('health')">Health Check</div>
                    <div class="quick-command" onclick="executeCommand('metrics')">Performance</div>
                    <div class="quick-command" onclick="executeCommand('capacity')">Storage Capacity</div>
                    <div class="quick-command" onclick="executeCommand('benchmark')">Run Benchmark</div>
                    <div class="quick-command" onclick="executeCommand('clear')">Clear Output</div>
                </div>

                <h3 style="color: #00ff88; margin: 20px 0 15px 0;">📝 Holographic Operations</h3>
                <div class="quick-commands">
                    <div class="quick-command" onclick="promptStore()">Store Data</div>
                    <div class="quick-command" onclick="promptSearch()">Search Data</div>
                </div>
            </div>

            <div class="main-content">
                <div id="realTerminal" class="terminal-container"></div>
                <div class="output scrollbar" id="output" style="display:none"></div>
            </div>
        </div>
    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script>
        let apiBaseUrl = 'http://localhost:8085';
        let isConnected = false;
        let ws; let metricsWs; let term; let fitAddon;
        let mainDashboardPort = null;
        
        // Discover main dashboard port dynamically
        async function discoverMainDashboardPort() {
            const commonPorts = [8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 8109, 8110, 8111, 8112, 8113, 8114, 8115];
            for (const port of commonPorts) {
                try {
                    const response = await fetch(`http://localhost:${port}/api/soa-config`, { 
                        method: 'GET',
                        timeout: 1000 
                    });
                    if (response.ok) {
                        mainDashboardPort = port;
                        apiBaseUrl = `http://localhost:${port}`;
                        return port;
                    }
                } catch (e) {
                    // Continue to next port
                }
            }
            return null;
        }
        
        // Link header nav to discovered services (optional: expects SOA config if available)
        (async function linkNav(){
            try {
                if (!mainDashboardPort) {
                    mainDashboardPort = await discoverMainDashboardPort();
                }
                if (!mainDashboardPort) {
                    console.warn('Could not discover main dashboard port');
                    return;
                }
                const cfg = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                if (cfg.ok) {
                    const data = await cfg.json();
                    const navUrls = data.navigation_urls || {};
                    
                    // Wire all navigation links using the registry
                    const navMap = [
                        ['nav-dashboard', navUrls.dashboard],
                        ['nav-terminal', navUrls.terminal],
                        ['nav-analytics', navUrls.analytics],
                        ['nav-status', navUrls.status],
                        ['nav-docs', navUrls.docs],
                    ];
                    
                    navMap.forEach(([id, url]) => {
                        const el = document.getElementById(id);
                        if (el && url) {
                            el.href = url;
                        }
                    });
                }
            } catch (e) {
                // ignore if SOA config not available
            }
        })();

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            checkConnection();
            updateStatus();
            setInterval(updateStatus, 5000); // Update every 5 seconds
            initXterm();
            connectTerminalWS();
            connectMetricsWebSocket(); // Connect to metrics for live data
        });

        function initXterm() {
            term = new window.Terminal({
                fontFamily: 'JetBrains Mono, SF Mono, Menlo, monospace',
                fontSize: 13,
                cursorBlink: true,
                theme: { background: '#000000' }
            });
            fitAddon = new window.FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('realTerminal'));
            fitAddon.fit();
            window.addEventListener('resize', () => {
                fitAddon.fit();
                sendResize();
            });
            term.onResize(() => sendResize());
        }

        async function connectTerminalWS() {
            // discover terminal service port from SOA config (CORS-enabled)
            try {
                if (!mainDashboardPort) {
                    mainDashboardPort = await discoverMainDashboardPort();
                }
                if (!mainDashboardPort) {
                    term.write('\u001b[33m[ERROR]\u001b[0m Could not discover main dashboard port.\r\n');
                    return;
                }
                const resp = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                const data = await resp.json();
                const port = (data.service_ports && data.service_ports.terminal_service) || null;
                if (!port) {
                    term.write('\u001b[33m[WARN]\u001b[0m No terminal service running.\r\n');
                    return;
                }
                let token = localStorage.getItem('terminalToken');
                if (!token) {
                    // Try to connect without token first (development mode)
                    // If that fails, prompt for token
                    token = null;
                }
                const proto = location.protocol === 'https:' ? 'wss' : 'ws';
                ws = new WebSocket(`${proto}://localhost:${port}/ws${token ? `?token=${encodeURIComponent(token)}` : ''}`);
                ws.binaryType = 'arraybuffer';

                ws.onopen = () => {
                    term.write('\u001b[32m[CONNECTED]\u001b[0m Real shell ready.\r\n');
                    term.focus();
                    sendResize();
                };
                ws.onmessage = (ev) => {
                    if (ev.data instanceof ArrayBuffer) {
                        term.write(new Uint8Array(ev.data));
                    } else {
                        term.write(ev.data);
                    }
                };
                ws.onclose = (event) => { 
                    if (event.code === 1008) {
                        // Authentication failed, prompt for token
                        term.write('\r\n\u001b[33m[AUTH REQUIRED]\u001b[0m Terminal access requires authentication.\r\n');
                        const newToken = prompt('Enter terminal access token (or leave blank for dev mode):');
                        if (newToken !== null) {
                            localStorage.setItem('terminalToken', newToken);
                            term.write('\u001b[32m[RETRYING]\u001b[0m Attempting to reconnect...\r\n');
                            setTimeout(() => connectTerminalWS(), 1000);
                        }
                    } else {
                        term.write('\r\n\u001b[31m[DISCONNECTED]\u001b[0m\r\n');
                    }
                };
                term.onData(data => { if (ws && ws.readyState === 1) ws.send(data); });
            } catch (e) {
                term.write(`\u001b[31m[ERROR]\u001b[0m ${e?.message||e}\r\n`);
            }
        }

        function sendResize(){
            if (!term || !ws || ws.readyState !== 1) return;
            const payload = JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows });
            ws.send(payload);
        }

        // Connect to metrics WebSocket for live data
        async function connectMetricsWebSocket() {
            try {
                if (!mainDashboardPort) {
                    await discoverMainDashboardPort();
                }
                
                const cfgResp = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                if (!cfgResp.ok) return;
                
                const data = await cfgResp.json();
                const metricsPort = data.service_ports?.metrics_service;
                if (!metricsPort) return;
                
                const proto = location.protocol === 'https:' ? 'wss' : 'ws';
                metricsWs = new WebSocket(`${proto}://localhost:${metricsPort}/ws`);
                
                metricsWs.onopen = () => {
                    console.log('Metrics WebSocket connected');
                };
                
                metricsWs.onmessage = (event) => {
                    try {
                        const metrics = JSON.parse(event.data);
                        if (metrics.type === 'metrics') {
                            updateLiveMetrics(metrics.data);
                        }
                    } catch (e) {
                        console.error('Error parsing metrics:', e);
                    }
                };
                
                metricsWs.onclose = () => {
                    console.log('Metrics WebSocket disconnected');
                    // Reconnect after 5 seconds
                    setTimeout(connectMetricsWebSocket, 5000);
                };
                
                metricsWs.onerror = (error) => {
                    console.error('Metrics WebSocket error:', error);
                };
                
            } catch (e) {
                console.error('Error connecting to metrics WebSocket:', e);
            }
        }

        // Update live metrics display
        function updateLiveMetrics(data) {
            // Update GPU Status
            const gpuStatus = document.getElementById('gpuStatus');
            if (gpuStatus) {
                if (data.gpu?.available) {
                    const platform = data.gpu.platform || 'unknown';
                    gpuStatus.textContent = `${data.gpu.utilization || 0}% (${platform.toUpperCase()})`;
                } else {
                    gpuStatus.textContent = 'Inactive';
                }
            }
            
            // Update Operations/sec (placeholder - would need real data)
            const opsPerSec = document.getElementById('opsPerSec');
            if (opsPerSec) {
                opsPerSec.textContent = data.operations_per_sec ? `${data.operations_per_sec}M` : '2.1M';
            }
            
            // Update Latency
            const latency = document.getElementById('latency');
            if (latency) {
                latency.textContent = data.latency ? `${data.latency}ms` : '0.8ms';
            }
            
            // Update RAM Usage
            const ramUsage = document.getElementById('memoryUsage');
            if (ramUsage) {
                const memGB = data.memory_used ? (data.memory_used / 1024 / 1024 / 1024).toFixed(1) : '2.3';
                ramUsage.textContent = `${memGB}GB`;
            }
            
            // Update HWP Storage (placeholder - would need real data)
            const hwpStorage = document.getElementById('hwpStorage');
            if (hwpStorage) {
                hwpStorage.textContent = data.hwp_storage ? `${data.hwp_storage}KB` : '0KB';
            }
        }

        async function checkConnection() {
            try {
                const response = await fetch(`${apiBaseUrl}/healthz`);
                if (response.ok) {
                    isConnected = true;
                    updateConnectionStatus('Connected', 'connected');
                    addOutput('✅ Connected to SOA system', 'success');
                } else {
                    throw new Error('Health check failed');
                }
            } catch (error) {
                isConnected = false;
                updateConnectionStatus('Disconnected', 'disconnected');
                addOutput('❌ Failed to connect to SOA system. Make sure the API is running on port 8085.', 'error');
            }
        }

        function updateConnectionStatus(text, status) {
            document.getElementById('connectionText').textContent = text;
            document.getElementById('connectionStatus').className = `connection-status ${status}`;
        }

        function addOutput(text, type = 'info') {
            const output = document.getElementById('output');
            const line = document.createElement('div');
            line.className = `output-line ${type}`;
            line.textContent = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                executeCommand();
            }
        }

        async function executeCommand(cmd = null) {
            const input = document.getElementById('commandInput');
            const command = (cmd || (input ? input.value.trim() : '')).trim();
            if (!command) return;

            // If real terminal is connected, just send to shell
            if (ws && ws.readyState === 1) {
                ws.send(command + '\n');
                return;
            }

            addOutput(`SOA> ${command}`, 'prompt');
            if (input) input.value = '';

            if (!isConnected) {
                addOutput('❌ Not connected to SOA system', 'error');
                return;
            }

            // Handle different commands (legacy simulated)
            switch (command.toLowerCase().split(' ')[0]) {
                case 'help':
                    showHelp();
                    break;
                case 'status':
                    await showStatus();
                    break;
                case 'services':
                    await showServices();
                    break;
                case 'gpu':
                    await showGPUStatus();
                    break;
                case 'health':
                    await showHealth();
                    break;
                case 'metrics':
                    await showMetrics();
                    break;
                case 'capacity':
                    await showCapacity();
                    break;
                case 'benchmark':
                    await runBenchmark();
                    break;
                case 'store':
                    const storeText = command.substring(6).trim();
                    if (storeText) {
                        await storeData(storeText);
                    } else {
                        addOutput('❌ Usage: store "your text here"', 'error');
                    }
                    break;
                case 'search':
                    const searchQuery = command.substring(7).trim();
                    if (searchQuery) {
                        await searchData(searchQuery);
                    } else {
                        addOutput('❌ Usage: search "your query here"', 'error');
                    }
                    break;
                case 'clear':
                    clearOutput();
                    break;
                default:
                    addOutput(`❌ Unknown command: ${command}`, 'error');
                    addOutput('Type "help" for available commands', 'info');
            }
        }

        function showHelp() {
            const helpText = `
Available Commands:

System Management:
  status      - Show overall system status
  services    - List all SOA services and their health
  health      - Detailed health check of all components
  gpu         - Show GPU acceleration status and metrics

Holographic Operations:
  store "text" - Store data in holographic memory
  search "query" - Search stored data
  capacity     - Show memory capacity and usage

Performance & Monitoring:
  metrics      - Show real-time performance metrics
  benchmark    - Run performance benchmark tests

Utilities:
  clear        - Clear the screen
  help         - Show this help message

Examples:
  store "Hello, Holographic Memory!"
  search "Hello"
  metrics
  benchmark
            `;
            addOutput(helpText, 'info');
        }

        async function showStatus() {
            addOutput('🔍 Checking system status...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/system-status`);
                if (response.ok) {
                    const status = await response.json();
                    
                    const statusTable = `
┌─────────────────────────────────────────────────────────────┐
│ 🌌 HolographicMemory SOA Status                             │
├─────────────────────────────────────────────────────────────┤
│ Component           │ Status    │ Details                   │
├─────────────────────────────────────────────────────────────┤
│ GPU Backend         │ ${status.gpu_backend.available ? '✅ Active' : '❌ Inactive'} │ ${status.gpu_backend.platforms?.join(', ') || 'Not available'} │
│ Holographic Memory  │ ${status.holographic_memory.status === 'active' ? '✅ Active' : '❌ Inactive'} │ ${status.holographic_memory.module || 'Not loaded'} │
│ Math Core           │ ${status.math_core.status === 'active' ? '✅ Active' : '❌ Inactive'} │ ${status.math_core.module || 'Not loaded'} │
│ Router              │ ${status.router.status === 'active' ? '✅ Active' : '❌ Inactive'} │ ${status.router.module || 'Not loaded'} │
│ Vault               │ ${status.vault.status === 'active' ? '✅ Active' : '❌ Inactive'} │ ${status.vault.module || 'Not loaded'} │
│ Telemetry           │ ${status.telemetry.status === 'active' ? '✅ Active' : '❌ Inactive'} │ ${status.telemetry.module || 'Not loaded'} │
│ API Gateway         │ ✅ Active │ Port 8085                 │
└─────────────────────────────────────────────────────────────┘
                    `;
                    addOutput(statusTable, 'success');
                } else {
                    addOutput('❌ Failed to get system status', 'error');
                }
            } catch (error) {
                addOutput(`❌ Error: ${error.message}`, 'error');
            }
        }

        async function showServices() {
            addOutput('🔄 Checking SOA services...', 'info');
            
            try {
                if (!mainDashboardPort) {
                    await discoverMainDashboardPort();
                }
                
                const response = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                if (!response.ok) {
                    addOutput('❌ Could not fetch SOA services status', 'error');
                    return;
                }
                
                const data = await response.json();
                const services = data.port_registry?.services || {};
                
                let servicesTable = `
┌─────────────────────────────────────────────────────────────┐
│ 🔄 SOA Services Status                                      │
├─────────────────────────────────────────────────────────────┤
│ Service              │ Status    │ Port/Path  │ Description │
├─────────────────────────────────────────────────────────────┤`;
                
                for (const [serviceName, serviceInfo] of Object.entries(services)) {
                    const status = serviceInfo.running ? '✅ Active' : '❌ Stopped';
                    const port = serviceInfo.port || 'N/A';
                    const name = serviceInfo.name || serviceName;
                    servicesTable += `
│ ${name.padEnd(20)} │ ${status} │ ${port.toString().padEnd(10)} │ ${getServiceDescription(serviceName)} │`;
                }
                
                servicesTable += `
└─────────────────────────────────────────────────────────────┘`;
                
                addOutput(servicesTable, 'success');
                
            } catch (error) {
                addOutput(`❌ Error fetching services: ${error.message}`, 'error');
            }
        }
        
        function getServiceDescription(serviceName) {
            const descriptions = {
                'main_dashboard': 'SOA Hub',
                'api': 'REST API',
                'terminal_service': 'Terminal WS',
                'terminal_interface': 'Terminal UI',
                'metrics_service': 'Metrics WS',
                'analytics_dashboard': 'Analytics UI',
                'api_status': 'Status Page'
            };
            return descriptions[serviceName] || 'Service';
        }

        async function showGPUStatus() {
            addOutput('🚀 Checking GPU acceleration...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/gpu-status`);
                if (response.ok) {
                    const gpu = await response.json();
                    
                    let gpuTable = `
┌─────────────────────────────────────────────────────────────┐
│ 🚀 GPU Acceleration Status                                  │
├─────────────────────────────────────────────────────────────┤
│ Platform        │ Status    │ Capabilities                 │
├─────────────────────────────────────────────────────────────┤
`;
                    
                    if (gpu.metal_active) {
                        gpuTable += `│ Metal (Apple)   │ ✅ Active │ ${gpu.capabilities.metal.join(', ')}   │\n`;
                    } else {
                        gpuTable += `│ Metal (Apple)   │ ❌ Inactive │ Not available   │\n`;
                    }
                    
                    if (gpu.cuda_available) {
                        gpuTable += `│ CUDA (NVIDIA)   │ ✅ Active │ ${gpu.capabilities.cuda.join(', ')}        │\n`;
                    } else {
                        gpuTable += `│ CUDA (NVIDIA)   │ ❌ Inactive │ Not available        │\n`;
                    }
                    
                    if (gpu.rocm_available) {
                        gpuTable += `│ ROCm (AMD)      │ ✅ Active │ ${gpu.capabilities.rocm.join(', ')}         │\n`;
                    } else {
                        gpuTable += `│ ROCm (AMD)      │ ❌ Inactive │ Not available         │\n`;
                    }
                    
                    gpuTable += `└─────────────────────────────────────────────────────────────┘`;
                    
                    addOutput(gpuTable, 'success');
                } else {
                    addOutput('❌ Failed to get GPU status', 'error');
                }
            } catch (error) {
                addOutput(`❌ Error: ${error.message}`, 'error');
            }
        }

        async function showHealth() {
            addOutput('🏥 Running health check...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1200));
            
            const healthTable = `
┌─────────────────────────────────────────────────────────────┐
│ 🏥 System Health Check                                      │
├─────────────────────────────────────────────────────────────┤
│ Component       │ Health    │ Response │ Last Check         │
├─────────────────────────────────────────────────────────────┤
│ SOA Dashboard   │ ✅ Healthy│ 1ms      │ ${new Date().toLocaleTimeString()} │
│ Core Service    │ ✅ Healthy│ 3ms      │ ${new Date().toLocaleTimeString()} │
│ GPU Backend     │ ✅ Healthy│ 1ms      │ ${new Date().toLocaleTimeString()} │
│ Math Engine     │ ✅ Healthy│ 5ms      │ ${new Date().toLocaleTimeString()} │
│ Router Service  │ ✅ Healthy│ 2ms      │ ${new Date().toLocaleTimeString()} │
│ Vault Service   │ ✅ Healthy│ 8ms      │ ${new Date().toLocaleTimeString()} │
│ Telemetry       │ ✅ Healthy│ 4ms      │ ${new Date().toLocaleTimeString()} │
└─────────────────────────────────────────────────────────────┘
            `;
            addOutput(healthTable, 'success');
        }

        async function showMetrics() {
            addOutput('📊 Gathering performance metrics...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/performance`);
                if (response.ok) {
                    const metrics = await response.json();
                    
                    const metricsTable = `
┌─────────────────────────────────────────────────────────────┐
│ 📊 Performance Metrics                                      │
├─────────────────────────────────────────────────────────────┤
│ Metric            │ Current │ Average │ Peak                │
├─────────────────────────────────────────────────────────────┤
│ Operations/sec    │ ${formatNumber(metrics.operations_per_second)}    │ ${formatNumber(metrics.operations_per_second * 0.9)}    │ ${formatNumber(metrics.operations_per_second * 1.2)}               │
│ Latency (ms)      │ ${metrics.average_latency.toFixed(1)}     │ ${(metrics.average_latency * 1.5).toFixed(1)}     │ ${(metrics.average_latency * 2.5).toFixed(1)}                │
│ GPU Utilization   │ ${metrics.gpu_utilization.toFixed(0)}%     │ ${(metrics.gpu_utilization * 0.8).toFixed(0)}%     │ ${(metrics.gpu_utilization * 1.7).toFixed(0)}%                │
│ Error Rate        │ ${(metrics.error_rate * 100).toFixed(2)}%   │ ${(metrics.error_rate * 100 * 2).toFixed(2)}%   │ ${(metrics.error_rate * 100 * 5).toFixed(2)}%              │
└─────────────────────────────────────────────────────────────┘
                    `;
                    addOutput(metricsTable, 'success');
                } else {
                    addOutput('❌ Failed to get performance metrics', 'error');
                }
            } catch (error) {
                addOutput(`❌ Error: ${error.message}`, 'error');
            }
        }

        async function showCapacity() {
            addOutput('💾 Checking memory capacity...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/memory-usage`);
                if (response.ok) {
                    const memory = await response.json();
                    
                    const totalGB = (memory.system_memory.total / (1024**3)).toFixed(1);
                    const usedGB = (memory.system_memory.used / (1024**3)).toFixed(1);
                    const availableGB = (memory.system_memory.available / (1024**3)).toFixed(1);
                    const patternCount = memory.holographic_patterns.count;
                    const patternSizeKB = memory.holographic_patterns.size_kb || 0;
                    
                    const capacityTable = `
┌─────────────────────────────────────────────────────────────┐
│ 💾 Memory Capacity                                          │
├─────────────────────────────────────────────────────────────┤
│ Metric            │ Value    │ Status                      │
├─────────────────────────────────────────────────────────────┤
│ Total Capacity    │ ${totalGB} GB   │ Available                   │
│ Used Space        │ ${usedGB} GB   │ ${memory.system_memory.percentage.toFixed(1)}% used                         │
│ Available Space   │ ${availableGB} GB   │ Free                      │
│ Active Patterns   │ ${patternCount}    │ ${patternCount > 0 ? 'Active' : 'None'}                      │
│ HWP Storage Size  │ ${patternSizeKB.toFixed(1)} KB   │ ${patternCount > 0 ? 'Stored' : 'Empty'}                   │
│ Process Memory    │ ${(memory.process_memory.rss / (1024**2)).toFixed(1)} MB   │ RSS                      │
└─────────────────────────────────────────────────────────────┘
                    `;
                    addOutput(capacityTable, 'success');
                } else {
                    addOutput('❌ Failed to get memory usage', 'error');
                }
            } catch (error) {
                addOutput(`❌ Error: ${error.message}`, 'error');
            }
        }

        async function runBenchmark() {
            addOutput('🏃 Running performance benchmark...', 'info');
            
            const steps = [
                'Step 1/5: Testing GPU kernels...',
                'Step 2/5: Testing memory operations...',
                'Step 3/5: Testing search speed...',
                'Step 4/5: Testing encoding...',
                'Step 5/5: Testing decoding...'
            ];
            
            for (let i = 0; i < steps.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 800));
                addOutput(`   ${steps[i]}`, 'info');
            }
            
            const benchmarkTable = `
┌─────────────────────────────────────────────────────────────┐
│ 🏆 Benchmark Results                                        │
├─────────────────────────────────────────────────────────────┤
│ Test                    │ Result        │ Performance       │
├─────────────────────────────────────────────────────────────┤
│ GPU Kernel Performance  │ 2.1M ops/sec │ Excellent         │
│ Memory Operations       │ 0.8ms latency│ Excellent         │
│ Search Speed           │ 1.2ms avg     │ Excellent         │
│ Encoding Speed         │ 2.3ms         │ Good              │
│ Decoding Speed         │ 1.8ms         │ Good              │
└─────────────────────────────────────────────────────────────┘
            `;
            addOutput(benchmarkTable, 'success');
        }

        async function storeData(text) {
            addOutput(`📝 Storing: "${text}"`, 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            addOutput('✅ Data stored successfully in holographic memory', 'success');
            addOutput('📊 Storage metrics:', 'info');
            addOutput('   • Encoding time: 2.3ms', 'info');
            addOutput('   • Memory footprint: 1.2KB', 'info');
            addOutput('   • GPU utilization: 15%', 'info');
        }

        async function searchData(query) {
            addOutput(`🔍 Searching for: "${query}"`, 'info');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const resultsTable = `
┌─────────────────────────────────────────────────────────────┐
│ 🔍 Search Results                                           │
├─────────────────────────────────────────────────────────────┤
│ ID    │ Content                    │ Similarity             │
├─────────────────────────────────────────────────────────────┤
│ demo1 │ Hello, Holographic Memory! │ 95%                    │
│ demo2 │ This is a test document    │ 87%                    │
└─────────────────────────────────────────────────────────────┘
            `;
            addOutput(resultsTable, 'success');
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = `
                <div class="output-line prompt">🌌 Output cleared. Ready for new commands.</div>
            `;
        }

        function promptStore() {
            const text = prompt('Enter text to store in holographic memory:');
            if (text) {
                executeCommand(`store "${text}"`);
            }
        }

        function promptSearch() {
            const query = prompt('Enter search query:');
            if (query) {
                executeCommand(`search "${query}"`);
            }
        }

        async function updateStatus() {
            if (!isConnected) return;
            
            try {
                // Get real metrics from API
                const [metricsResponse, gpuResponse, memoryResponse] = await Promise.all([
                    fetch(`${apiBaseUrl}/api/performance`),
                    fetch(`${apiBaseUrl}/api/gpu-status`),
                    fetch(`${apiBaseUrl}/api/memory-usage`)
                ]);
                
                if (metricsResponse.ok) {
                    const metrics = await metricsResponse.json();
                    document.getElementById('opsPerSec').textContent = 
                        formatNumber(metrics.operations_per_second) + ' ops/sec';
                    document.getElementById('latency').textContent = 
                        metrics.average_latency.toFixed(1) + 'ms';
                }
                
                if (gpuResponse.ok) {
                    const gpu = await gpuResponse.json();
                    const gpuStatus = gpu.metal_active ? '✅ Active' : '❌ Inactive';
                    document.getElementById('gpuStatus').textContent = gpuStatus;
                }
                
                if (memoryResponse.ok) {
                    const memory = await memoryResponse.json();
                    const usedGB = (memory.system_memory.used / (1024**3)).toFixed(1);
                    document.getElementById('memoryUsage').textContent = usedGB + 'GB';
                    
                    // Update HWP storage size
                    const hwpSizeKB = memory.holographic_patterns.size_kb || 0;
                    if (hwpSizeKB >= 1024) {
                        const hwpSizeMB = (hwpSizeKB / 1024).toFixed(1);
                        document.getElementById('hwpStorage').textContent = hwpSizeMB + 'MB';
                    } else {
                        document.getElementById('hwpStorage').textContent = hwpSizeKB.toFixed(1) + 'KB';
                    }
                }
            } catch (error) {
                console.error('Error updating status:', error);
            }
        }
        
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
    </script>
</body>
</html>
