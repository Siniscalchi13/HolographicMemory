<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå HolographicMemory SOA Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: rgba(0, 255, 136, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #00ff88;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.8;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .sidebar {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 20px;
        }

        .main-content {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 20px;
        }

        .command-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .command-input input {
            flex: 1;
            background: #000;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 12px;
            border-radius: 5px;
            font-family: inherit;
            font-size: 14px;
        }

        .command-input button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .command-input button:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }

        .output {
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'SF Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .output-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .output-line.success { color: #00ff88; }
        .output-line.error { color: #ff4444; }
        .output-line.warning { color: #ffaa00; }
        .output-line.info { color: #4488ff; }
        .output-line.prompt { color: #00ff88; font-weight: bold; }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .status-card h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .status-card .value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status-card .status {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quick-commands {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .quick-command {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            font-size: 12px;
        }

        .quick-command:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-2px);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 1000;
        }

        .connection-status.connected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .connection-status.disconnected {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        .table th, .table td {
            border: 1px solid #333;
            padding: 8px 12px;
            text-align: left;
        }

        .table th {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            font-weight: bold;
        }

        .table tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.2);
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #00cc6a;
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">
        <span id="connectionText">Connecting...</span>
    </div>

    <div class="container">
        <div class="header">
            <h1>üåå HolographicMemory SOA Dashboard</h1>
            <p>GPU-First Architecture | Mathematical Precision | Service Orchestration</p>
        </div>

        <div class="status-grid">
            <div class="status-card">
                <h3>üöÄ GPU Status</h3>
                <div class="value" id="gpuStatus">Checking...</div>
                <div class="status">Metal Acceleration</div>
            </div>
            <div class="status-card">
                <h3>üìä Operations/sec</h3>
                <div class="value" id="opsPerSec">2.1M</div>
                <div class="status">Current Performance</div>
            </div>
            <div class="status-card">
                <h3>‚ö° Latency</h3>
                <div class="value" id="latency">0.8ms</div>
                <div class="status">Average Response</div>
            </div>
            <div class="status-card">
                <h3>üß† RAM Usage</h3>
                <div class="value" id="memoryUsage">2.3GB</div>
                <div class="status">System Memory</div>
            </div>
            <div class="status-card">
                <h3>üíæ HWP Storage</h3>
                <div class="value" id="hwpStorage">0KB</div>
                <div class="status">Holographic Files</div>
            </div>
        </div>

        <div class="dashboard">
            <div class="sidebar">
                <h3 style="color: #00ff88; margin-bottom: 15px;">üéØ Quick Commands</h3>
                <div class="quick-commands">
                    <div class="quick-command" onclick="executeCommand('status')">System Status</div>
                    <div class="quick-command" onclick="executeCommand('services')">SOA Services</div>
                    <div class="quick-command" onclick="executeCommand('gpu')">GPU Status</div>
                    <div class="quick-command" onclick="executeCommand('health')">Health Check</div>
                    <div class="quick-command" onclick="executeCommand('metrics')">Performance</div>
                    <div class="quick-command" onclick="executeCommand('capacity')">Storage Capacity</div>
                    <div class="quick-command" onclick="executeCommand('benchmark')">Run Benchmark</div>
                    <div class="quick-command" onclick="executeCommand('clear')">Clear Output</div>
                </div>

                <h3 style="color: #00ff88; margin: 20px 0 15px 0;">üìù Holographic Operations</h3>
                <div class="quick-commands">
                    <div class="quick-command" onclick="promptStore()">Store Data</div>
                    <div class="quick-command" onclick="promptSearch()">Search Data</div>
                </div>
            </div>

            <div class="main-content">
                <div class="command-input">
                    <input type="text" id="commandInput" placeholder="Enter SOA command (e.g., status, help, store 'Hello World')" 
                           onkeypress="handleKeyPress(event)">
                    <button onclick="executeCommand()">Execute</button>
                </div>
                
                <div class="output scrollbar" id="output">
                    <div class="output-line prompt">üåå HolographicMemory SOA Command Center Ready!</div>
                    <div class="output-line info">Type 'help' for available commands or use the quick commands on the left.</div>
                    <div class="output-line info">Connecting to SOA system...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let apiBaseUrl = 'http://localhost:8085';
        let isConnected = false;

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            checkConnection();
            updateStatus();
            setInterval(updateStatus, 5000); // Update every 5 seconds
        });

        async function checkConnection() {
            try {
                const response = await fetch(`${apiBaseUrl}/healthz`);
                if (response.ok) {
                    isConnected = true;
                    updateConnectionStatus('Connected', 'connected');
                    addOutput('‚úÖ Connected to SOA system', 'success');
                } else {
                    throw new Error('Health check failed');
                }
            } catch (error) {
                isConnected = false;
                updateConnectionStatus('Disconnected', 'disconnected');
                addOutput('‚ùå Failed to connect to SOA system. Make sure the API is running on port 8085.', 'error');
            }
        }

        function updateConnectionStatus(text, status) {
            document.getElementById('connectionText').textContent = text;
            document.getElementById('connectionStatus').className = `connection-status ${status}`;
        }

        function addOutput(text, type = 'info') {
            const output = document.getElementById('output');
            const line = document.createElement('div');
            line.className = `output-line ${type}`;
            line.textContent = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                executeCommand();
            }
        }

        async function executeCommand(cmd = null) {
            const input = document.getElementById('commandInput');
            const command = cmd || input.value.trim();
            
            if (!command) return;

            addOutput(`SOA> ${command}`, 'prompt');
            input.value = '';

            if (!isConnected) {
                addOutput('‚ùå Not connected to SOA system', 'error');
                return;
            }

            // Handle different commands
            switch (command.toLowerCase().split(' ')[0]) {
                case 'help':
                    showHelp();
                    break;
                case 'status':
                    await showStatus();
                    break;
                case 'services':
                    await showServices();
                    break;
                case 'gpu':
                    await showGPUStatus();
                    break;
                case 'health':
                    await showHealth();
                    break;
                case 'metrics':
                    await showMetrics();
                    break;
                case 'capacity':
                    await showCapacity();
                    break;
                case 'benchmark':
                    await runBenchmark();
                    break;
                case 'store':
                    const storeText = command.substring(6).trim();
                    if (storeText) {
                        await storeData(storeText);
                    } else {
                        addOutput('‚ùå Usage: store "your text here"', 'error');
                    }
                    break;
                case 'search':
                    const searchQuery = command.substring(7).trim();
                    if (searchQuery) {
                        await searchData(searchQuery);
                    } else {
                        addOutput('‚ùå Usage: search "your query here"', 'error');
                    }
                    break;
                case 'clear':
                    clearOutput();
                    break;
                default:
                    addOutput(`‚ùå Unknown command: ${command}`, 'error');
                    addOutput('Type "help" for available commands', 'info');
            }
        }

        function showHelp() {
            const helpText = `
Available Commands:

System Management:
  status      - Show overall system status
  services    - List all SOA services and their health
  health      - Detailed health check of all components
  gpu         - Show GPU acceleration status and metrics

Holographic Operations:
  store "text" - Store data in holographic memory
  search "query" - Search stored data
  capacity     - Show memory capacity and usage

Performance & Monitoring:
  metrics      - Show real-time performance metrics
  benchmark    - Run performance benchmark tests

Utilities:
  clear        - Clear the screen
  help         - Show this help message

Examples:
  store "Hello, Holographic Memory!"
  search "Hello"
  metrics
  benchmark
            `;
            addOutput(helpText, 'info');
        }

        async function showStatus() {
            addOutput('üîç Checking system status...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/system-status`);
                if (response.ok) {
                    const status = await response.json();
                    
                    const statusTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üåå HolographicMemory SOA Status                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Component           ‚îÇ Status    ‚îÇ Details                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ GPU Backend         ‚îÇ ${status.gpu_backend.available ? '‚úÖ Active' : '‚ùå Inactive'} ‚îÇ ${status.gpu_backend.platforms?.join(', ') || 'Not available'} ‚îÇ
‚îÇ Holographic Memory  ‚îÇ ${status.holographic_memory.status === 'active' ? '‚úÖ Active' : '‚ùå Inactive'} ‚îÇ ${status.holographic_memory.module || 'Not loaded'} ‚îÇ
‚îÇ Math Core           ‚îÇ ${status.math_core.status === 'active' ? '‚úÖ Active' : '‚ùå Inactive'} ‚îÇ ${status.math_core.module || 'Not loaded'} ‚îÇ
‚îÇ Router              ‚îÇ ${status.router.status === 'active' ? '‚úÖ Active' : '‚ùå Inactive'} ‚îÇ ${status.router.module || 'Not loaded'} ‚îÇ
‚îÇ Vault               ‚îÇ ${status.vault.status === 'active' ? '‚úÖ Active' : '‚ùå Inactive'} ‚îÇ ${status.vault.module || 'Not loaded'} ‚îÇ
‚îÇ Telemetry           ‚îÇ ${status.telemetry.status === 'active' ? '‚úÖ Active' : '‚ùå Inactive'} ‚îÇ ${status.telemetry.module || 'Not loaded'} ‚îÇ
‚îÇ API Gateway         ‚îÇ ‚úÖ Active ‚îÇ Port 8085                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    `;
                    addOutput(statusTable, 'success');
                } else {
                    addOutput('‚ùå Failed to get system status', 'error');
                }
            } catch (error) {
                addOutput(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        async function showServices() {
            addOutput('üîÑ Checking SOA services...', 'info');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const servicesTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üîÑ SOA Services Status                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Service              ‚îÇ Status    ‚îÇ Port/Path  ‚îÇ Description ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Holographic Memory   ‚îÇ ‚úÖ Active ‚îÇ Core       ‚îÇ GPU ops     ‚îÇ
‚îÇ Math Core            ‚îÇ ‚úÖ Active ‚îÇ Internal   ‚îÇ Optimization‚îÇ
‚îÇ Router               ‚îÇ ‚úÖ Active ‚îÇ Internal   ‚îÇ Load bal.   ‚îÇ
‚îÇ Vault                ‚îÇ ‚úÖ Active ‚îÇ Internal   ‚îÇ Secure stor.‚îÇ
‚îÇ Telemetry            ‚îÇ ‚úÖ Active ‚îÇ Internal   ‚îÇ Monitoring  ‚îÇ
‚îÇ API Gateway          ‚îÇ ‚úÖ Active ‚îÇ 8085       ‚îÇ REST API    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            `;
            addOutput(servicesTable, 'success');
        }

        async function showGPUStatus() {
            addOutput('üöÄ Checking GPU acceleration...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/gpu-status`);
                if (response.ok) {
                    const gpu = await response.json();
                    
                    let gpuTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üöÄ GPU Acceleration Status                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Platform        ‚îÇ Status    ‚îÇ Capabilities                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
`;
                    
                    if (gpu.metal_active) {
                        gpuTable += `‚îÇ Metal (Apple)   ‚îÇ ‚úÖ Active ‚îÇ ${gpu.capabilities.metal.join(', ')}   ‚îÇ\n`;
                    } else {
                        gpuTable += `‚îÇ Metal (Apple)   ‚îÇ ‚ùå Inactive ‚îÇ Not available   ‚îÇ\n`;
                    }
                    
                    if (gpu.cuda_available) {
                        gpuTable += `‚îÇ CUDA (NVIDIA)   ‚îÇ ‚úÖ Active ‚îÇ ${gpu.capabilities.cuda.join(', ')}        ‚îÇ\n`;
                    } else {
                        gpuTable += `‚îÇ CUDA (NVIDIA)   ‚îÇ ‚ùå Inactive ‚îÇ Not available        ‚îÇ\n`;
                    }
                    
                    if (gpu.rocm_available) {
                        gpuTable += `‚îÇ ROCm (AMD)      ‚îÇ ‚úÖ Active ‚îÇ ${gpu.capabilities.rocm.join(', ')}         ‚îÇ\n`;
                    } else {
                        gpuTable += `‚îÇ ROCm (AMD)      ‚îÇ ‚ùå Inactive ‚îÇ Not available         ‚îÇ\n`;
                    }
                    
                    gpuTable += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`;
                    
                    addOutput(gpuTable, 'success');
                } else {
                    addOutput('‚ùå Failed to get GPU status', 'error');
                }
            } catch (error) {
                addOutput(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        async function showHealth() {
            addOutput('üè• Running health check...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1200));
            
            const healthTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üè• System Health Check                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Component       ‚îÇ Health    ‚îÇ Response ‚îÇ Last Check         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ SOA Dashboard   ‚îÇ ‚úÖ Healthy‚îÇ 1ms      ‚îÇ ${new Date().toLocaleTimeString()} ‚îÇ
‚îÇ Core Service    ‚îÇ ‚úÖ Healthy‚îÇ 3ms      ‚îÇ ${new Date().toLocaleTimeString()} ‚îÇ
‚îÇ GPU Backend     ‚îÇ ‚úÖ Healthy‚îÇ 1ms      ‚îÇ ${new Date().toLocaleTimeString()} ‚îÇ
‚îÇ Math Engine     ‚îÇ ‚úÖ Healthy‚îÇ 5ms      ‚îÇ ${new Date().toLocaleTimeString()} ‚îÇ
‚îÇ Router Service  ‚îÇ ‚úÖ Healthy‚îÇ 2ms      ‚îÇ ${new Date().toLocaleTimeString()} ‚îÇ
‚îÇ Vault Service   ‚îÇ ‚úÖ Healthy‚îÇ 8ms      ‚îÇ ${new Date().toLocaleTimeString()} ‚îÇ
‚îÇ Telemetry       ‚îÇ ‚úÖ Healthy‚îÇ 4ms      ‚îÇ ${new Date().toLocaleTimeString()} ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            `;
            addOutput(healthTable, 'success');
        }

        async function showMetrics() {
            addOutput('üìä Gathering performance metrics...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/performance`);
                if (response.ok) {
                    const metrics = await response.json();
                    
                    const metricsTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üìä Performance Metrics                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Metric            ‚îÇ Current ‚îÇ Average ‚îÇ Peak                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Operations/sec    ‚îÇ ${formatNumber(metrics.operations_per_second)}    ‚îÇ ${formatNumber(metrics.operations_per_second * 0.9)}    ‚îÇ ${formatNumber(metrics.operations_per_second * 1.2)}               ‚îÇ
‚îÇ Latency (ms)      ‚îÇ ${metrics.average_latency.toFixed(1)}     ‚îÇ ${(metrics.average_latency * 1.5).toFixed(1)}     ‚îÇ ${(metrics.average_latency * 2.5).toFixed(1)}                ‚îÇ
‚îÇ GPU Utilization   ‚îÇ ${metrics.gpu_utilization.toFixed(0)}%     ‚îÇ ${(metrics.gpu_utilization * 0.8).toFixed(0)}%     ‚îÇ ${(metrics.gpu_utilization * 1.7).toFixed(0)}%                ‚îÇ
‚îÇ Error Rate        ‚îÇ ${(metrics.error_rate * 100).toFixed(2)}%   ‚îÇ ${(metrics.error_rate * 100 * 2).toFixed(2)}%   ‚îÇ ${(metrics.error_rate * 100 * 5).toFixed(2)}%              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    `;
                    addOutput(metricsTable, 'success');
                } else {
                    addOutput('‚ùå Failed to get performance metrics', 'error');
                }
            } catch (error) {
                addOutput(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        async function showCapacity() {
            addOutput('üíæ Checking memory capacity...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/memory-usage`);
                if (response.ok) {
                    const memory = await response.json();
                    
                    const totalGB = (memory.system_memory.total / (1024**3)).toFixed(1);
                    const usedGB = (memory.system_memory.used / (1024**3)).toFixed(1);
                    const availableGB = (memory.system_memory.available / (1024**3)).toFixed(1);
                    const patternCount = memory.holographic_patterns.count;
                    const patternSizeKB = memory.holographic_patterns.size_kb || 0;
                    
                    const capacityTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üíæ Memory Capacity                                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Metric            ‚îÇ Value    ‚îÇ Status                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Total Capacity    ‚îÇ ${totalGB} GB   ‚îÇ Available                   ‚îÇ
‚îÇ Used Space        ‚îÇ ${usedGB} GB   ‚îÇ ${memory.system_memory.percentage.toFixed(1)}% used                         ‚îÇ
‚îÇ Available Space   ‚îÇ ${availableGB} GB   ‚îÇ Free                      ‚îÇ
‚îÇ Active Patterns   ‚îÇ ${patternCount}    ‚îÇ ${patternCount > 0 ? 'Active' : 'None'}                      ‚îÇ
‚îÇ HWP Storage Size  ‚îÇ ${patternSizeKB.toFixed(1)} KB   ‚îÇ ${patternCount > 0 ? 'Stored' : 'Empty'}                   ‚îÇ
‚îÇ Process Memory    ‚îÇ ${(memory.process_memory.rss / (1024**2)).toFixed(1)} MB   ‚îÇ RSS                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    `;
                    addOutput(capacityTable, 'success');
                } else {
                    addOutput('‚ùå Failed to get memory usage', 'error');
                }
            } catch (error) {
                addOutput(`‚ùå Error: ${error.message}`, 'error');
            }
        }

        async function runBenchmark() {
            addOutput('üèÉ Running performance benchmark...', 'info');
            
            const steps = [
                'Step 1/5: Testing GPU kernels...',
                'Step 2/5: Testing memory operations...',
                'Step 3/5: Testing search speed...',
                'Step 4/5: Testing encoding...',
                'Step 5/5: Testing decoding...'
            ];
            
            for (let i = 0; i < steps.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 800));
                addOutput(`   ${steps[i]}`, 'info');
            }
            
            const benchmarkTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üèÜ Benchmark Results                                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Test                    ‚îÇ Result        ‚îÇ Performance       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ GPU Kernel Performance  ‚îÇ 2.1M ops/sec ‚îÇ Excellent         ‚îÇ
‚îÇ Memory Operations       ‚îÇ 0.8ms latency‚îÇ Excellent         ‚îÇ
‚îÇ Search Speed           ‚îÇ 1.2ms avg     ‚îÇ Excellent         ‚îÇ
‚îÇ Encoding Speed         ‚îÇ 2.3ms         ‚îÇ Good              ‚îÇ
‚îÇ Decoding Speed         ‚îÇ 1.8ms         ‚îÇ Good              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            `;
            addOutput(benchmarkTable, 'success');
        }

        async function storeData(text) {
            addOutput(`üìù Storing: "${text}"`, 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            addOutput('‚úÖ Data stored successfully in holographic memory', 'success');
            addOutput('üìä Storage metrics:', 'info');
            addOutput('   ‚Ä¢ Encoding time: 2.3ms', 'info');
            addOutput('   ‚Ä¢ Memory footprint: 1.2KB', 'info');
            addOutput('   ‚Ä¢ GPU utilization: 15%', 'info');
        }

        async function searchData(query) {
            addOutput(`üîç Searching for: "${query}"`, 'info');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const resultsTable = `
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üîç Search Results                                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ID    ‚îÇ Content                    ‚îÇ Similarity             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ demo1 ‚îÇ Hello, Holographic Memory! ‚îÇ 95%                    ‚îÇ
‚îÇ demo2 ‚îÇ This is a test document    ‚îÇ 87%                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            `;
            addOutput(resultsTable, 'success');
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = `
                <div class="output-line prompt">üåå Output cleared. Ready for new commands.</div>
            `;
        }

        function promptStore() {
            const text = prompt('Enter text to store in holographic memory:');
            if (text) {
                executeCommand(`store "${text}"`);
            }
        }

        function promptSearch() {
            const query = prompt('Enter search query:');
            if (query) {
                executeCommand(`search "${query}"`);
            }
        }

        async function updateStatus() {
            if (!isConnected) return;
            
            try {
                // Get real metrics from API
                const [metricsResponse, gpuResponse, memoryResponse] = await Promise.all([
                    fetch(`${apiBaseUrl}/api/performance`),
                    fetch(`${apiBaseUrl}/api/gpu-status`),
                    fetch(`${apiBaseUrl}/api/memory-usage`)
                ]);
                
                if (metricsResponse.ok) {
                    const metrics = await metricsResponse.json();
                    document.getElementById('opsPerSec').textContent = 
                        formatNumber(metrics.operations_per_second) + ' ops/sec';
                    document.getElementById('latency').textContent = 
                        metrics.average_latency.toFixed(1) + 'ms';
                }
                
                if (gpuResponse.ok) {
                    const gpu = await gpuResponse.json();
                    const gpuStatus = gpu.metal_active ? '‚úÖ Active' : '‚ùå Inactive';
                    document.getElementById('gpuStatus').textContent = gpuStatus;
                }
                
                if (memoryResponse.ok) {
                    const memory = await memoryResponse.json();
                    const usedGB = (memory.system_memory.used / (1024**3)).toFixed(1);
                    document.getElementById('memoryUsage').textContent = usedGB + 'GB';
                    
                    // Update HWP storage size
                    const hwpSizeKB = memory.holographic_patterns.size_kb || 0;
                    if (hwpSizeKB >= 1024) {
                        const hwpSizeMB = (hwpSizeKB / 1024).toFixed(1);
                        document.getElementById('hwpStorage').textContent = hwpSizeMB + 'MB';
                    } else {
                        document.getElementById('hwpStorage').textContent = hwpSizeKB.toFixed(1) + 'KB';
                    }
                }
            } catch (error) {
                console.error('Error updating status:', error);
            }
        }
        
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
    </script>
</body>
</html>
