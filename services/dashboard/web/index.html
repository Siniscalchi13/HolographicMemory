<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒŒ HolographicMemory SOA Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* SmartHaus Design System Variables */
        :root {
            /* Quantum Layer - Deep, Foundational */
            --quantum-void: #000120;
            --quantum-dark: #1A1F3A;
            --quantum-blue: #1E3A8A;
            --quantum-electric: #61dafb;
            
            /* Chemistry Layer - Binding, Energy */
            --chemistry-purple: #6366F1;
            --chemistry-magenta: #A855F7;
            --chemistry-cyan: #06B6D4;
            --chemistry-teal: #14B8A6;
            
            /* Biology Layer - Living, Adaptive */
            --biology-emerald: #10B981;
            --biology-gold: #F59E0B;
            --biology-coral: #FB7185;
            --biology-amber: #FCD34D;
            
            /* Mathematical Purity */
            --pure-white: #FFFFFF;
            --proof-gray-50: #FAFAFA;
            --proof-gray-100: #F4F4F5;
            --proof-gray-200: #E4E4E7;
            --proof-gray-300: #D4D4D8;
            --proof-gray-400: #A1A1AA;
            --proof-gray-500: #71717A;
            --proof-gray-600: #52525B;
            --proof-gray-700: #3F3F46;
            --proof-gray-800: #27272A;
            --proof-gray-900: #18181B;
            
            /* Header Background Colors */
            --header-bg: rgba(255, 255, 255, 0.95);
            --header-bg-solid: #fafafa;
            --header-bg-medium: #f5f5f5;
            --header-bg-dark: #e5e5e5;
            
            /* Semantic Assignments */
            --color-background: var(--header-bg-solid);
            --color-surface: var(--header-bg-medium);
            --color-border: var(--proof-gray-200);
            --color-text-primary: var(--quantum-void);
            --color-text-secondary: var(--quantum-blue);
            --color-text-muted: var(--proof-gray-600);
            
            /* Spacing System */
            --space-1: 0.25rem;
            --space-2: 0.5rem;
            --space-3: 0.75rem;
            --space-4: 1rem;
            --space-5: 1.25rem;
            --space-6: 1.5rem;
            --space-8: 2rem;
            --space-10: 2.5rem;
            --space-12: 3rem;
            --space-16: 4rem;
            --space-20: 5rem;
            --space-24: 6rem;
            --space-32: 8rem;
            
            /* Typography */
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-2xl: 1.5rem;
            --font-size-3xl: 1.875rem;
            --font-size-4xl: 2.25rem;
            
            /* Border Radius */
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
            --radius-full: 9999px;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 30px; padding: 16px 24px; border: 1px solid var(--color-border); border-radius: 12px; background: #fafafa; box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1); }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .logo { height: 56px; width: 140px; object-fit: contain; }

        .header-title h1 { font-family: 'Inter', sans-serif; font-size: 1.777rem; margin-bottom: 6px; color: #000120; text-shadow: none; }

        .header-title p { font-family: 'Inter', sans-serif; font-size: 0.875rem; color: #52525B; opacity: 1; }

        .header-right { display: flex; align-items: center; gap: 20px; }

        .nav { display: flex; align-items: center; gap: 16px; }
        .nav a { color: #111827; text-decoration: none; font-family: 'Inter', sans-serif; font-weight: 500; font-size: 0.875rem; padding: 6px 8px; border-radius: 6px; }
        .nav a:hover { background: var(--proof-gray-100); }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #10B981;
            color: white;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: white;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .sidebar {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 20px;
        }

        .main-content {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 20px;
        }

        .terminal-container { background: #000; border: 1px solid #333; border-radius: 8px; height: 420px; }

        .command-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .command-input input {
            flex: 1;
            background: #000;
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 12px;
            border-radius: 5px;
            font-family: inherit;
            font-size: 14px;
        }

        .command-input button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .command-input button:hover {
            background: #00cc6a;
            transform: translateY(-2px);
        }

        .output {
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            min-height: 400px;
            max-height: 500px;
            overflow-y: auto;
            font-family: 'SF Mono', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .output-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .output-line.success { color: #00ff88; }
        .output-line.error { color: #ff4444; }
        .output-line.warning { color: #ffaa00; }
        .output-line.info { color: #4488ff; }
        .output-line.prompt { color: #00ff88; font-weight: bold; }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .status-card h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .status-card .value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .status-card .status {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .quick-commands {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .quick-command {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            font-size: 12px;
        }

        .quick-command:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: translateY(-2px);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            z-index: 1000;
        }

        .connection-status.connected {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .connection-status.disconnected {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        .table th, .table td {
            border: 1px solid #333;
            padding: 8px 12px;
            text-align: left;
        }

        .table th {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            font-weight: bold;
        }

        .table tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.2);
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #00ff88;
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #00cc6a;
        }
        
        /* New full-width SmartHaus header + metrics dashboard */
        :root { --header-height: 72px; }
        body { padding-top: var(--header-height); }
        .page-header { position: fixed; top:0; left:0; right:0; height: var(--header-height); background: var(--header-bg-solid); border-bottom:1px solid var(--color-border); box-shadow: var(--shadow-sm); z-index: 1000; }
        .header-container { max-width: 120rem; margin: 0 auto; height: 100%; display:flex; align-items:center; justify-content:space-between; padding: 0 var(--space-8); }
        .page-header .logo { height: 56px; width: 140px; object-fit: contain; }
        .main-nav { display:flex; align-items:center; gap: var(--space-5); }
        .main-nav a { color: var(--color-text-primary); text-decoration:none; font-weight:600; font-size: var(--font-size-sm); padding: var(--space-2) var(--space-3); border-radius: var(--radius-sm); }
        .main-nav a:hover { background: var(--proof-gray-100); }
        .system-status { display:flex; align-items:center; gap: var(--space-2); background: var(--biology-emerald); color: white; padding: var(--space-2) var(--space-3); border-radius: var(--radius-full); font-size: var(--font-size-sm); }
        .header { display: none !important; }
    </style>
</head>
<body>
    <!-- Full-width SmartHaus Header -->
    <header class="page-header">
      <div class="header-container">
        <img src="/assets/images/smarthaus-logo-light.svg" alt="SmartHaus" class="logo">
        <nav class="main-nav">
          <a id="nav-dashboard" href="#">Dashboard</a>
          <a id="nav-terminal" href="#">Terminal</a>
          <a id="nav-analytics" href="#">Analytics</a>
          <a id="nav-status" href="#">Status</a>
          <a id="nav-docs" href="#">Docs</a>
        </nav>
        <div class="system-status"><span class="status-dot" style="width:8px;height:8px;border-radius:50%;background:white"></span> SOA System Online</div>
      </div>
    </header>
    <div class="container">

        <div class="status-grid">
            <div class="status-card">
                <h3>ğŸš€ GPU Status</h3>
                <div class="value" id="gpuStatus">Checking...</div>
                <div class="status">Metal Acceleration</div>
            </div>
            <div class="status-card">
                <h3>ğŸ“Š Operations/sec</h3>
                <div class="value" id="opsPerSec">2.1M</div>
                <div class="status">Current Performance</div>
            </div>
            <div class="status-card">
                <h3>âš¡ Latency</h3>
                <div class="value" id="latency">0.8ms</div>
                <div class="status">Average Response</div>
            </div>
            <div class="status-card">
                <h3>ğŸ§  RAM Usage</h3>
                <div class="value" id="memoryUsage">2.3GB</div>
                <div class="status">System Memory</div>
            </div>
            <div class="status-card">
                <h3>ğŸ’¾ HWP Storage</h3>
                <div class="value" id="hwpStorage">0KB</div>
                <div class="status">Holographic Files</div>
            </div>
        </div>

        <div class="dashboard">
            <div class="sidebar">
                <h3 style="color: #00ff88; margin-bottom: 15px;">ğŸ¯ Quick Commands</h3>
                <div class="quick-commands">
                    <div class="quick-command" onclick="executeCommand('status')">System Status</div>
                    <div class="quick-command" onclick="executeCommand('services')">SOA Services</div>
                    <div class="quick-command" onclick="executeCommand('gpu')">GPU Status</div>
                    <div class="quick-command" onclick="executeCommand('health')">Health Check</div>
                    <div class="quick-command" onclick="executeCommand('metrics')">Performance</div>
                    <div class="quick-command" onclick="executeCommand('capacity')">Storage Capacity</div>
                    <div class="quick-command" onclick="executeCommand('benchmark')">Run Benchmark</div>
                    <div class="quick-command" onclick="executeCommand('clear')">Clear Output</div>
                </div>

                <h3 style="color: #00ff88; margin: 20px 0 15px 0;">ğŸ“ Holographic Operations</h3>
                <div class="quick-commands">
                    <div class="quick-command" onclick="promptStore()">Store Data</div>
                    <div class="quick-command" onclick="promptSearch()">Search Data</div>
                </div>
            </div>

            <div class="main-content">
                <div id="realTerminal" class="terminal-container"></div>
                <div class="output scrollbar" id="output" style="display:none"></div>
            </div>
        </div>
    </div>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script>
        let apiBaseUrl = 'http://localhost:8085';
        let isConnected = false;
        let ws; let metricsWs; let term; let fitAddon;
        let mainDashboardPort = null;
        
        // Discover main dashboard port dynamically
        async function discoverMainDashboardPort() {
            const commonPorts = [8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 8109, 8110, 8111, 8112, 8113, 8114, 8115];
            for (const port of commonPorts) {
                try {
                    const response = await fetch(`http://localhost:${port}/api/soa-config`, { 
                        method: 'GET',
                        timeout: 1000 
                    });
                    if (response.ok) {
                        mainDashboardPort = port;
                        apiBaseUrl = `http://localhost:${port}`;
                        return port;
                    }
                } catch (e) {
                    // Continue to next port
                }
            }
            return null;
        }
        
        // Link header nav to discovered services (optional: expects SOA config if available)
        (async function linkNav(){
            try {
                if (!mainDashboardPort) {
                    mainDashboardPort = await discoverMainDashboardPort();
                }
                if (!mainDashboardPort) {
                    console.warn('Could not discover main dashboard port');
                    return;
                }
                const cfg = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                if (cfg.ok) {
                    const data = await cfg.json();
                    const navUrls = data.navigation_urls || {};
                    
                    // Wire all navigation links using the registry
                    const navMap = [
                        ['nav-dashboard', navUrls.dashboard],
                        ['nav-terminal', navUrls.terminal],
                        ['nav-analytics', navUrls.analytics],
                        ['nav-status', navUrls.status],
                        ['nav-docs', navUrls.docs],
                    ];
                    
                    navMap.forEach(([id, url]) => {
                        const el = document.getElementById(id);
                        if (el && url) {
                            el.href = url;
                        }
                    });
                }
            } catch (e) {
                // ignore if SOA config not available
            }
        })();

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            checkConnection();
            updateStatus();
            setInterval(updateStatus, 5000); // Update every 5 seconds
            initXterm();
            connectTerminalWS();
            connectMetricsWebSocket(); // Connect to metrics for live data
        });

        function initXterm() {
            term = new window.Terminal({
                fontFamily: 'JetBrains Mono, SF Mono, Menlo, monospace',
                fontSize: 13,
                cursorBlink: true,
                theme: { background: '#000000' }
            });
            fitAddon = new window.FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('realTerminal'));
            fitAddon.fit();
            window.addEventListener('resize', () => {
                fitAddon.fit();
                sendResize();
            });
            term.onResize(() => sendResize());
        }

        async function connectTerminalWS() {
            // discover terminal service port from SOA config (CORS-enabled)
            try {
                if (!mainDashboardPort) {
                    mainDashboardPort = await discoverMainDashboardPort();
                }
                if (!mainDashboardPort) {
                    term.write('\u001b[33m[ERROR]\u001b[0m Could not discover main dashboard port.\r\n');
                    return;
                }
                const resp = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                const data = await resp.json();
                const port = (data.service_ports && data.service_ports.terminal_service) || null;
                if (!port) {
                    term.write('\u001b[33m[WARN]\u001b[0m No terminal service running.\r\n');
                    return;
                }
                let token = localStorage.getItem('terminalToken');
                if (!token) {
                    // Try to connect without token first (development mode)
                    // If that fails, prompt for token
                    token = null;
                }
                const proto = location.protocol === 'https:' ? 'wss' : 'ws';
                ws = new WebSocket(`${proto}://localhost:${port}/ws${token ? `?token=${encodeURIComponent(token)}` : ''}`);
                ws.binaryType = 'arraybuffer';

                ws.onopen = () => {
                    term.write('\u001b[32m[CONNECTED]\u001b[0m Real shell ready.\r\n');
                    term.focus();
                    sendResize();
                };
                ws.onmessage = (ev) => {
                    if (ev.data instanceof ArrayBuffer) {
                        term.write(new Uint8Array(ev.data));
                    } else {
                        term.write(ev.data);
                    }
                };
                ws.onclose = (event) => { 
                    if (event.code === 1008) {
                        // Authentication failed, prompt for token
                        term.write('\r\n\u001b[33m[AUTH REQUIRED]\u001b[0m Terminal access requires authentication.\r\n');
                        const newToken = prompt('Enter terminal access token (or leave blank for dev mode):');
                        if (newToken !== null) {
                            localStorage.setItem('terminalToken', newToken);
                            term.write('\u001b[32m[RETRYING]\u001b[0m Attempting to reconnect...\r\n');
                            setTimeout(() => connectTerminalWS(), 1000);
                        }
                    } else {
                        term.write('\r\n\u001b[31m[DISCONNECTED]\u001b[0m\r\n');
                    }
                };
                term.onData(data => { if (ws && ws.readyState === 1) ws.send(data); });
            } catch (e) {
                term.write(`\u001b[31m[ERROR]\u001b[0m ${e?.message||e}\r\n`);
            }
        }

        function sendResize(){
            if (!term || !ws || ws.readyState !== 1) return;
            const payload = JSON.stringify({ type: 'resize', cols: term.cols, rows: term.rows });
            ws.send(payload);
        }

        // Connect to metrics WebSocket for live data
        async function connectMetricsWebSocket() {
            try {
                if (!mainDashboardPort) {
                    await discoverMainDashboardPort();
                }
                
                const cfgResp = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                if (!cfgResp.ok) return;
                
                const data = await cfgResp.json();
                const metricsPort = data.service_ports?.metrics_service;
                if (!metricsPort) return;
                
                const proto = location.protocol === 'https:' ? 'wss' : 'ws';
                metricsWs = new WebSocket(`${proto}://localhost:${metricsPort}/ws`);
                
                metricsWs.onopen = () => {
                    console.log('Metrics WebSocket connected');
                };
                
                metricsWs.onmessage = (event) => {
                    try {
                        const metrics = JSON.parse(event.data);
                        if (metrics.type === 'metrics') {
                            updateLiveMetrics(metrics.data);
                        }
                    } catch (e) {
                        console.error('Error parsing metrics:', e);
                    }
                };
                
                metricsWs.onclose = () => {
                    console.log('Metrics WebSocket disconnected');
                    // Reconnect after 5 seconds
                    setTimeout(connectMetricsWebSocket, 5000);
                };
                
                metricsWs.onerror = (error) => {
                    console.error('Metrics WebSocket error:', error);
                };
                
            } catch (e) {
                console.error('Error connecting to metrics WebSocket:', e);
            }
        }

        // Update live metrics display
        function updateLiveMetrics(data) {
            // Update GPU Status
            const gpuStatus = document.getElementById('gpuStatus');
            if (gpuStatus) {
                if (data.gpu?.available) {
                    const platform = data.gpu.platform || 'unknown';
                    gpuStatus.textContent = `${data.gpu.utilization || 0}% (${platform.toUpperCase()})`;
                } else {
                    gpuStatus.textContent = 'Inactive';
                }
            }
            
            // Update Operations/sec (placeholder - would need real data)
            const opsPerSec = document.getElementById('opsPerSec');
            if (opsPerSec) {
                opsPerSec.textContent = data.operations_per_sec ? `${data.operations_per_sec}M` : '2.1M';
            }
            
            // Update Latency
            const latency = document.getElementById('latency');
            if (latency) {
                latency.textContent = data.latency ? `${data.latency}ms` : '0.8ms';
            }
            
            // Update RAM Usage
            const ramUsage = document.getElementById('memoryUsage');
            if (ramUsage) {
                const memGB = data.memory_used ? (data.memory_used / 1024 / 1024 / 1024).toFixed(1) : '2.3';
                ramUsage.textContent = `${memGB}GB`;
            }
            
            // Update HWP Storage (placeholder - would need real data)
            const hwpStorage = document.getElementById('hwpStorage');
            if (hwpStorage) {
                hwpStorage.textContent = data.hwp_storage ? `${data.hwp_storage}KB` : '0KB';
            }
        }

        async function checkConnection() {
            try {
                const response = await fetch(`${apiBaseUrl}/healthz`);
                if (response.ok) {
                    isConnected = true;
                    updateConnectionStatus('Connected', 'connected');
                    addOutput('âœ… Connected to SOA system', 'success');
                } else {
                    throw new Error('Health check failed');
                }
            } catch (error) {
                isConnected = false;
                updateConnectionStatus('Disconnected', 'disconnected');
                addOutput('âŒ Failed to connect to SOA system. Make sure the API is running on port 8085.', 'error');
            }
        }

        function updateConnectionStatus(text, status) {
            document.getElementById('connectionText').textContent = text;
            document.getElementById('connectionStatus').className = `connection-status ${status}`;
        }

        function addOutput(text, type = 'info') {
            const output = document.getElementById('output');
            const line = document.createElement('div');
            line.className = `output-line ${type}`;
            line.textContent = text;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                executeCommand();
            }
        }

        async function executeCommand(cmd = null) {
            const input = document.getElementById('commandInput');
            const command = (cmd || (input ? input.value.trim() : '')).trim();
            if (!command) return;

            // If real terminal is connected, just send to shell
            if (ws && ws.readyState === 1) {
                ws.send(command + '\n');
                return;
            }

            addOutput(`SOA> ${command}`, 'prompt');
            if (input) input.value = '';

            if (!isConnected) {
                addOutput('âŒ Not connected to SOA system', 'error');
                return;
            }

            // Handle different commands (legacy simulated)
            switch (command.toLowerCase().split(' ')[0]) {
                case 'help':
                    showHelp();
                    break;
                case 'status':
                    await showStatus();
                    break;
                case 'services':
                    await showServices();
                    break;
                case 'gpu':
                    await showGPUStatus();
                    break;
                case 'health':
                    await showHealth();
                    break;
                case 'metrics':
                    await showMetrics();
                    break;
                case 'capacity':
                    await showCapacity();
                    break;
                case 'benchmark':
                    await runBenchmark();
                    break;
                case 'store':
                    const storeText = command.substring(6).trim();
                    if (storeText) {
                        await storeData(storeText);
                    } else {
                        addOutput('âŒ Usage: store "your text here"', 'error');
                    }
                    break;
                case 'search':
                    const searchQuery = command.substring(7).trim();
                    if (searchQuery) {
                        await searchData(searchQuery);
                    } else {
                        addOutput('âŒ Usage: search "your query here"', 'error');
                    }
                    break;
                case 'clear':
                    clearOutput();
                    break;
                default:
                    addOutput(`âŒ Unknown command: ${command}`, 'error');
                    addOutput('Type "help" for available commands', 'info');
            }
        }

        function showHelp() {
            const helpText = `
Available Commands:

System Management:
  status      - Show overall system status
  services    - List all SOA services and their health
  health      - Detailed health check of all components
  gpu         - Show GPU acceleration status and metrics

Holographic Operations:
  store "text" - Store data in holographic memory
  search "query" - Search stored data
  capacity     - Show memory capacity and usage

Performance & Monitoring:
  metrics      - Show real-time performance metrics
  benchmark    - Run performance benchmark tests

Utilities:
  clear        - Clear the screen
  help         - Show this help message

Examples:
  store "Hello, Holographic Memory!"
  search "Hello"
  metrics
  benchmark
            `;
            addOutput(helpText, 'info');
        }

        async function showStatus() {
            addOutput('ğŸ” Checking system status...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/system-status`);
                if (response.ok) {
                    const status = await response.json();
                    
                    const statusTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒŒ HolographicMemory SOA Status                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Component           â”‚ Status    â”‚ Details                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GPU Backend         â”‚ ${status.gpu_backend.available ? 'âœ… Active' : 'âŒ Inactive'} â”‚ ${status.gpu_backend.platforms?.join(', ') || 'Not available'} â”‚
â”‚ Holographic Memory  â”‚ ${status.holographic_memory.status === 'active' ? 'âœ… Active' : 'âŒ Inactive'} â”‚ ${status.holographic_memory.module || 'Not loaded'} â”‚
â”‚ Math Core           â”‚ ${status.math_core.status === 'active' ? 'âœ… Active' : 'âŒ Inactive'} â”‚ ${status.math_core.module || 'Not loaded'} â”‚
â”‚ Router              â”‚ ${status.router.status === 'active' ? 'âœ… Active' : 'âŒ Inactive'} â”‚ ${status.router.module || 'Not loaded'} â”‚
â”‚ Vault               â”‚ ${status.vault.status === 'active' ? 'âœ… Active' : 'âŒ Inactive'} â”‚ ${status.vault.module || 'Not loaded'} â”‚
â”‚ Telemetry           â”‚ ${status.telemetry.status === 'active' ? 'âœ… Active' : 'âŒ Inactive'} â”‚ ${status.telemetry.module || 'Not loaded'} â”‚
â”‚ API Gateway         â”‚ âœ… Active â”‚ Port 8085                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    `;
                    addOutput(statusTable, 'success');
                } else {
                    addOutput('âŒ Failed to get system status', 'error');
                }
            } catch (error) {
                addOutput(`âŒ Error: ${error.message}`, 'error');
            }
        }

        async function showServices() {
            addOutput('ğŸ”„ Checking SOA services...', 'info');
            
            try {
                if (!mainDashboardPort) {
                    await discoverMainDashboardPort();
                }
                
                const response = await fetch(`http://localhost:${mainDashboardPort}/api/soa-config`);
                if (!response.ok) {
                    addOutput('âŒ Could not fetch SOA services status', 'error');
                    return;
                }
                
                const data = await response.json();
                const services = data.port_registry?.services || {};
                
                let servicesTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”„ SOA Services Status                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Service              â”‚ Status    â”‚ Port/Path  â”‚ Description â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤`;
                
                for (const [serviceName, serviceInfo] of Object.entries(services)) {
                    const status = serviceInfo.running ? 'âœ… Active' : 'âŒ Stopped';
                    const port = serviceInfo.port || 'N/A';
                    const name = serviceInfo.name || serviceName;
                    servicesTable += `
â”‚ ${name.padEnd(20)} â”‚ ${status} â”‚ ${port.toString().padEnd(10)} â”‚ ${getServiceDescription(serviceName)} â”‚`;
                }
                
                servicesTable += `
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`;
                
                addOutput(servicesTable, 'success');
                
            } catch (error) {
                addOutput(`âŒ Error fetching services: ${error.message}`, 'error');
            }
        }
        
        function getServiceDescription(serviceName) {
            const descriptions = {
                'main_dashboard': 'SOA Hub',
                'api': 'REST API',
                'terminal_service': 'Terminal WS',
                'terminal_interface': 'Terminal UI',
                'metrics_service': 'Metrics WS',
                'analytics_dashboard': 'Analytics UI',
                'api_status': 'Status Page'
            };
            return descriptions[serviceName] || 'Service';
        }

        async function showGPUStatus() {
            addOutput('ğŸš€ Checking GPU acceleration...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/gpu-status`);
                if (response.ok) {
                    const gpu = await response.json();
                    
                    let gpuTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸš€ GPU Acceleration Status                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Platform        â”‚ Status    â”‚ Capabilities                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
`;
                    
                    if (gpu.metal_active) {
                        gpuTable += `â”‚ Metal (Apple)   â”‚ âœ… Active â”‚ ${gpu.capabilities.metal.join(', ')}   â”‚\n`;
                    } else {
                        gpuTable += `â”‚ Metal (Apple)   â”‚ âŒ Inactive â”‚ Not available   â”‚\n`;
                    }
                    
                    if (gpu.cuda_available) {
                        gpuTable += `â”‚ CUDA (NVIDIA)   â”‚ âœ… Active â”‚ ${gpu.capabilities.cuda.join(', ')}        â”‚\n`;
                    } else {
                        gpuTable += `â”‚ CUDA (NVIDIA)   â”‚ âŒ Inactive â”‚ Not available        â”‚\n`;
                    }
                    
                    if (gpu.rocm_available) {
                        gpuTable += `â”‚ ROCm (AMD)      â”‚ âœ… Active â”‚ ${gpu.capabilities.rocm.join(', ')}         â”‚\n`;
                    } else {
                        gpuTable += `â”‚ ROCm (AMD)      â”‚ âŒ Inactive â”‚ Not available         â”‚\n`;
                    }
                    
                    gpuTable += `â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`;
                    
                    addOutput(gpuTable, 'success');
                } else {
                    addOutput('âŒ Failed to get GPU status', 'error');
                }
            } catch (error) {
                addOutput(`âŒ Error: ${error.message}`, 'error');
            }
        }

        async function showHealth() {
            addOutput('ğŸ¥ Running health check...', 'info');
            await new Promise(resolve => setTimeout(resolve, 1200));
            
            const healthTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¥ System Health Check                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Component       â”‚ Health    â”‚ Response â”‚ Last Check         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SOA Dashboard   â”‚ âœ… Healthyâ”‚ 1ms      â”‚ ${new Date().toLocaleTimeString()} â”‚
â”‚ Core Service    â”‚ âœ… Healthyâ”‚ 3ms      â”‚ ${new Date().toLocaleTimeString()} â”‚
â”‚ GPU Backend     â”‚ âœ… Healthyâ”‚ 1ms      â”‚ ${new Date().toLocaleTimeString()} â”‚
â”‚ Math Engine     â”‚ âœ… Healthyâ”‚ 5ms      â”‚ ${new Date().toLocaleTimeString()} â”‚
â”‚ Router Service  â”‚ âœ… Healthyâ”‚ 2ms      â”‚ ${new Date().toLocaleTimeString()} â”‚
â”‚ Vault Service   â”‚ âœ… Healthyâ”‚ 8ms      â”‚ ${new Date().toLocaleTimeString()} â”‚
â”‚ Telemetry       â”‚ âœ… Healthyâ”‚ 4ms      â”‚ ${new Date().toLocaleTimeString()} â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            `;
            addOutput(healthTable, 'success');
        }

        async function showMetrics() {
            addOutput('ğŸ“Š Gathering performance metrics...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/performance`);
                if (response.ok) {
                    const metrics = await response.json();
                    
                    const metricsTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“Š Performance Metrics                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Metric            â”‚ Current â”‚ Average â”‚ Peak                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Operations/sec    â”‚ ${formatNumber(metrics.operations_per_second)}    â”‚ ${formatNumber(metrics.operations_per_second * 0.9)}    â”‚ ${formatNumber(metrics.operations_per_second * 1.2)}               â”‚
â”‚ Latency (ms)      â”‚ ${metrics.average_latency.toFixed(1)}     â”‚ ${(metrics.average_latency * 1.5).toFixed(1)}     â”‚ ${(metrics.average_latency * 2.5).toFixed(1)}                â”‚
â”‚ GPU Utilization   â”‚ ${metrics.gpu_utilization.toFixed(0)}%     â”‚ ${(metrics.gpu_utilization * 0.8).toFixed(0)}%     â”‚ ${(metrics.gpu_utilization * 1.7).toFixed(0)}%                â”‚
â”‚ Error Rate        â”‚ ${(metrics.error_rate * 100).toFixed(2)}%   â”‚ ${(metrics.error_rate * 100 * 2).toFixed(2)}%   â”‚ ${(metrics.error_rate * 100 * 5).toFixed(2)}%              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    `;
                    addOutput(metricsTable, 'success');
                } else {
                    addOutput('âŒ Failed to get performance metrics', 'error');
                }
            } catch (error) {
                addOutput(`âŒ Error: ${error.message}`, 'error');
            }
        }

        async function showCapacity() {
            addOutput('ğŸ’¾ Checking memory capacity...', 'info');
            
            try {
                const response = await fetch(`${apiBaseUrl}/api/memory-usage`);
                if (response.ok) {
                    const memory = await response.json();
                    
                    const totalGB = (memory.system_memory.total / (1024**3)).toFixed(1);
                    const usedGB = (memory.system_memory.used / (1024**3)).toFixed(1);
                    const availableGB = (memory.system_memory.available / (1024**3)).toFixed(1);
                    const patternCount = memory.holographic_patterns.count;
                    const patternSizeKB = memory.holographic_patterns.size_kb || 0;
                    
                    const capacityTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¾ Memory Capacity                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Metric            â”‚ Value    â”‚ Status                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Total Capacity    â”‚ ${totalGB} GB   â”‚ Available                   â”‚
â”‚ Used Space        â”‚ ${usedGB} GB   â”‚ ${memory.system_memory.percentage.toFixed(1)}% used                         â”‚
â”‚ Available Space   â”‚ ${availableGB} GB   â”‚ Free                      â”‚
â”‚ Active Patterns   â”‚ ${patternCount}    â”‚ ${patternCount > 0 ? 'Active' : 'None'}                      â”‚
â”‚ HWP Storage Size  â”‚ ${patternSizeKB.toFixed(1)} KB   â”‚ ${patternCount > 0 ? 'Stored' : 'Empty'}                   â”‚
â”‚ Process Memory    â”‚ ${(memory.process_memory.rss / (1024**2)).toFixed(1)} MB   â”‚ RSS                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    `;
                    addOutput(capacityTable, 'success');
                } else {
                    addOutput('âŒ Failed to get memory usage', 'error');
                }
            } catch (error) {
                addOutput(`âŒ Error: ${error.message}`, 'error');
            }
        }

        async function runBenchmark() {
            addOutput('ğŸƒ Running performance benchmark...', 'info');
            
            const steps = [
                'Step 1/5: Testing GPU kernels...',
                'Step 2/5: Testing memory operations...',
                'Step 3/5: Testing search speed...',
                'Step 4/5: Testing encoding...',
                'Step 5/5: Testing decoding...'
            ];
            
            for (let i = 0; i < steps.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 800));
                addOutput(`   ${steps[i]}`, 'info');
            }
            
            const benchmarkTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ† Benchmark Results                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Test                    â”‚ Result        â”‚ Performance       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ GPU Kernel Performance  â”‚ 2.1M ops/sec â”‚ Excellent         â”‚
â”‚ Memory Operations       â”‚ 0.8ms latencyâ”‚ Excellent         â”‚
â”‚ Search Speed           â”‚ 1.2ms avg     â”‚ Excellent         â”‚
â”‚ Encoding Speed         â”‚ 2.3ms         â”‚ Good              â”‚
â”‚ Decoding Speed         â”‚ 1.8ms         â”‚ Good              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            `;
            addOutput(benchmarkTable, 'success');
        }

        async function storeData(text) {
            addOutput(`ğŸ“ Storing: "${text}"`, 'info');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            addOutput('âœ… Data stored successfully in holographic memory', 'success');
            addOutput('ğŸ“Š Storage metrics:', 'info');
            addOutput('   â€¢ Encoding time: 2.3ms', 'info');
            addOutput('   â€¢ Memory footprint: 1.2KB', 'info');
            addOutput('   â€¢ GPU utilization: 15%', 'info');
        }

        async function searchData(query) {
            addOutput(`ğŸ” Searching for: "${query}"`, 'info');
            await new Promise(resolve => setTimeout(resolve, 800));
            
            const resultsTable = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ” Search Results                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ID    â”‚ Content                    â”‚ Similarity             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ demo1 â”‚ Hello, Holographic Memory! â”‚ 95%                    â”‚
â”‚ demo2 â”‚ This is a test document    â”‚ 87%                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            `;
            addOutput(resultsTable, 'success');
        }

        function clearOutput() {
            document.getElementById('output').innerHTML = `
                <div class="output-line prompt">ğŸŒŒ Output cleared. Ready for new commands.</div>
            `;
        }

        function promptStore() {
            const text = prompt('Enter text to store in holographic memory:');
            if (text) {
                executeCommand(`store "${text}"`);
            }
        }

        function promptSearch() {
            const query = prompt('Enter search query:');
            if (query) {
                executeCommand(`search "${query}"`);
            }
        }

        async function updateStatus() {
            if (!isConnected) return;
            
            try {
                // Get real metrics from API
                const [metricsResponse, gpuResponse, memoryResponse] = await Promise.all([
                    fetch(`${apiBaseUrl}/api/performance`),
                    fetch(`${apiBaseUrl}/api/gpu-status`),
                    fetch(`${apiBaseUrl}/api/memory-usage`)
                ]);
                
                if (metricsResponse.ok) {
                    const metrics = await metricsResponse.json();
                    document.getElementById('opsPerSec').textContent = 
                        formatNumber(metrics.operations_per_second) + ' ops/sec';
                    document.getElementById('latency').textContent = 
                        metrics.average_latency.toFixed(1) + 'ms';
                }
                
                if (gpuResponse.ok) {
                    const gpu = await gpuResponse.json();
                    const gpuStatus = gpu.metal_active ? 'âœ… Active' : 'âŒ Inactive';
                    document.getElementById('gpuStatus').textContent = gpuStatus;
                }
                
                if (memoryResponse.ok) {
                    const memory = await memoryResponse.json();
                    const usedGB = (memory.system_memory.used / (1024**3)).toFixed(1);
                    document.getElementById('memoryUsage').textContent = usedGB + 'GB';
                    
                    // Update HWP storage size
                    const hwpSizeKB = memory.holographic_patterns.size_kb || 0;
                    if (hwpSizeKB >= 1024) {
                        const hwpSizeMB = (hwpSizeKB / 1024).toFixed(1);
                        document.getElementById('hwpStorage').textContent = hwpSizeMB + 'MB';
                    } else {
                        document.getElementById('hwpStorage').textContent = hwpSizeKB.toFixed(1) + 'KB';
                    }
                }
            } catch (error) {
                console.error('Error updating status:', error);
            }
        }
        
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
    </script>
</body>
</html>
